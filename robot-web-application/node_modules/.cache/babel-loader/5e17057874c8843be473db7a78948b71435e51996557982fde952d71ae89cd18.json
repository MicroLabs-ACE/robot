{"ast":null,"code":"class Graph {\n  constructor(length, width) {\n    this.graph = {};\n    this.generateGraph(length, width);\n  }\n  generateGraph(length, width) {\n    this.length = length;\n    this.width = width;\n    for (let i = 0; i < this.length; i++) for (let j = 0; j < this.width; j++) {\n      const nodes = {\n        north: [i, j - 1],\n        northEast: [i + 1, j - 1],\n        east: [i + 1, j],\n        southEast: [i + 1, j + 1],\n        south: [i, j + 1],\n        southWest: [i - 1, j + 1],\n        west: [i - 1, j],\n        northWest: [i - 1, j - 1]\n      };\n      for (const [node, coordinates] of Object.entries(nodes)) {\n        const [x, y] = coordinates;\n        var horizontalCondition = x >= 0 && x < this.length;\n        var verticalCondition = y >= 0 && y < this.width;\n        if (horizontalCondition && verticalCondition) {\n          if (node === \"north\" || node === \"south\") this.addEdge(`${i}${j}`, `${x}${y}`, 10);else if (node === \"west\" || node === \"east\") this.addEdge(`${i}-${j}`, `${x}-${y}`, 10);else this.addEdge(`${i}-${j}`, `${x}-${y}`, 14);\n        }\n      }\n    }\n  }\n  doesNodeExist(node) {\n    return this.graph.hasOwnProperty(node);\n  }\n  addEdge(src, dst, weight) {\n    if (!this.doesNodeExist(src)) {\n      this.graph[src] = {\n        [dst]: weight\n      };\n    } else {\n      this.graph[src][dst] = weight;\n    }\n    if (!this.doesNodeExist(dst)) {\n      this.graph[dst] = {};\n    }\n  }\n  getDistance(src, dst) {\n    return this.graph[src][dst];\n  }\n  getDirection(src, dst) {\n    const [x0, y0] = src.split(\"-\");\n    const [x1, y1] = dst.split(\"-\");\n    const dx = Number(x1) - Number(x0);\n    const dy = Number(y1) - Number(y0);\n    let direction;\n    if (dx === 0 && dy === 1) direction = 0;else if (dx === 1 && dy === 1) direction = 45;else if (dx === 1 && dy === 0) direction = 90;else if (dx === 1 && dy === -1) direction = 135;else if (dx === 0 && dy === -1) direction = 180;else if (dx === -1 && dy === -1) direction = 225;else if (dx === -1 && dy === 0) direction = 270;else if (dx === -1 && dy === 1) direction = 315;\n    return direction;\n  }\n  dijkstra(start, end) {\n    const findLowestCostNode = (costs, processed) => {\n      let lowestCost = Infinity;\n      let lowestCostNode = null;\n      for (const node in costs) {\n        const cost = costs[node];\n        if (cost < lowestCost && !processed.includes(node)) {\n          lowestCost = cost;\n          lowestCostNode = node;\n        }\n      }\n      return lowestCostNode;\n    };\n    const nodesExceptStart = Object.keys(this.graph).filter(node => node !== start);\n    const costs = {};\n    const parents = {};\n    const processed = [];\n    nodesExceptStart.forEach(node => {\n      costs[node] = Infinity;\n      parents[node] = null;\n    });\n    const startNeighbors = Object.keys(this.graph[start]);\n    startNeighbors.forEach(node => {\n      parents[node] = start;\n      costs[node] = this.graph[start][node];\n    });\n    let currentNode = findLowestCostNode(costs, processed);\n    while (currentNode !== null) {\n      const cost = costs[currentNode];\n      const neighbors = this.graph[currentNode];\n      for (const n in neighbors) {\n        const newCost = cost + neighbors[n];\n        if (costs[n] > newCost) {\n          costs[n] = newCost;\n          parents[n] = currentNode;\n        }\n      }\n      processed.push(currentNode);\n      currentNode = findLowestCostNode(costs, processed);\n    }\n    let path = [end];\n    let point = parents[end];\n    while (point !== start) {\n      path.unshift(point);\n      point = parents[point];\n    }\n    path.unshift(start);\n    return path;\n  }\n  dfs(start) {\n    const stack = [start];\n    const visited = new Set();\n    visited.add(start);\n    while (stack.length > 0) {\n      const currentNode = stack.pop();\n      const neighbors = this.graph[currentNode];\n      for (const neighbor in neighbors) {\n        if (!visited.has(neighbor)) {\n          stack.push(neighbor);\n          visited.add(neighbor);\n        }\n      }\n    }\n  }\n  bfs(start) {\n    const queue = [start];\n    const visited = new Set();\n    visited.add(start);\n    while (queue.length > 0) {\n      const currentNode = queue.shift();\n      const neighbors = this.graph[currentNode];\n      for (const neighbor in neighbors) {\n        if (!visited.has(neighbor)) {\n          queue.push(neighbor);\n          visited.add(neighbor);\n        }\n      }\n    }\n  }\n}\nfunction dijkstra_computation(length, width, start, end) {\n  const graph = new Graph(length, width);\n  return graph.dijkstra(start, end);\n}\nexport default dijkstra_computation;","map":{"version":3,"names":["Graph","constructor","length","width","graph","generateGraph","i","j","nodes","north","northEast","east","southEast","south","southWest","west","northWest","node","coordinates","Object","entries","x","y","horizontalCondition","verticalCondition","addEdge","doesNodeExist","hasOwnProperty","src","dst","weight","getDistance","getDirection","x0","y0","split","x1","y1","dx","Number","dy","direction","dijkstra","start","end","findLowestCostNode","costs","processed","lowestCost","Infinity","lowestCostNode","cost","includes","nodesExceptStart","keys","filter","parents","forEach","startNeighbors","currentNode","neighbors","n","newCost","push","path","point","unshift","dfs","stack","visited","Set","add","pop","neighbor","has","bfs","queue","shift","dijkstra_computation"],"sources":["/home/victor/Documents/Programming/Hardware Engineering/robot/robot-web-application/src/graph.js"],"sourcesContent":["class Graph {\n  constructor(length, width) {\n    this.graph = {};\n    this.generateGraph(length, width);\n  }\n\n  generateGraph(length, width) {\n    this.length = length;\n    this.width = width;\n\n    for (let i = 0; i < this.length; i++)\n      for (let j = 0; j < this.width; j++) {\n        const nodes = {\n          north: [i, j - 1],\n          northEast: [i + 1, j - 1],\n          east: [i + 1, j],\n          southEast: [i + 1, j + 1],\n          south: [i, j + 1],\n          southWest: [i - 1, j + 1],\n          west: [i - 1, j],\n          northWest: [i - 1, j - 1],\n        };\n\n        for (const [node, coordinates] of Object.entries(nodes)) {\n          const [x, y] = coordinates;\n          var horizontalCondition = x >= 0 && x < this.length;\n          var verticalCondition = y >= 0 && y < this.width;\n\n          if (horizontalCondition && verticalCondition) {\n            if (node === \"north\" || node === \"south\")\n              this.addEdge(`${i}${j}`, `${x}${y}`, 10);\n            else if (node === \"west\" || node === \"east\")\n              this.addEdge(`${i}-${j}`, `${x}-${y}`, 10);\n            else this.addEdge(`${i}-${j}`, `${x}-${y}`, 14);\n          }\n        }\n      }\n  }\n\n  doesNodeExist(node) {\n    return this.graph.hasOwnProperty(node);\n  }\n\n  addEdge(src, dst, weight) {\n    if (!this.doesNodeExist(src)) {\n      this.graph[src] = { [dst]: weight };\n    } else {\n      this.graph[src][dst] = weight;\n    }\n\n    if (!this.doesNodeExist(dst)) {\n      this.graph[dst] = {};\n    }\n  }\n\n  getDistance(src, dst) {\n    return this.graph[src][dst];\n  }\n\n  getDirection(src, dst) {\n    const [x0, y0] = src.split(\"-\");\n    const [x1, y1] = dst.split(\"-\");\n\n    const dx = Number(x1) - Number(x0);\n    const dy = Number(y1) - Number(y0);\n\n    let direction;\n    if (dx === 0 && dy === 1) direction = 0;\n    else if (dx === 1 && dy === 1) direction = 45;\n    else if (dx === 1 && dy === 0) direction = 90;\n    else if (dx === 1 && dy === -1) direction = 135;\n    else if (dx === 0 && dy === -1) direction = 180;\n    else if (dx === -1 && dy === -1) direction = 225;\n    else if (dx === -1 && dy === 0) direction = 270;\n    else if (dx === -1 && dy === 1) direction = 315;\n\n    return direction;\n  }\n\n  dijkstra(start, end) {\n    const findLowestCostNode = (costs, processed) => {\n      let lowestCost = Infinity;\n      let lowestCostNode = null;\n      for (const node in costs) {\n        const cost = costs[node];\n        if (cost < lowestCost && !processed.includes(node)) {\n          lowestCost = cost;\n          lowestCostNode = node;\n        }\n      }\n      return lowestCostNode;\n    };\n\n    const nodesExceptStart = Object.keys(this.graph).filter(\n      (node) => node !== start\n    );\n    const costs = {};\n    const parents = {};\n    const processed = [];\n\n    nodesExceptStart.forEach((node) => {\n      costs[node] = Infinity;\n      parents[node] = null;\n    });\n\n    const startNeighbors = Object.keys(this.graph[start]);\n    startNeighbors.forEach((node) => {\n      parents[node] = start;\n      costs[node] = this.graph[start][node];\n    });\n\n    let currentNode = findLowestCostNode(costs, processed);\n    while (currentNode !== null) {\n      const cost = costs[currentNode];\n      const neighbors = this.graph[currentNode];\n\n      for (const n in neighbors) {\n        const newCost = cost + neighbors[n];\n        if (costs[n] > newCost) {\n          costs[n] = newCost;\n          parents[n] = currentNode;\n        }\n      }\n      processed.push(currentNode);\n      currentNode = findLowestCostNode(costs, processed);\n    }\n\n    let path = [end];\n    let point = parents[end];\n    while (point !== start) {\n      path.unshift(point);\n      point = parents[point];\n    }\n    path.unshift(start);\n    return path;\n  }\n\n  dfs(start) {\n    const stack = [start];\n    const visited = new Set();\n    visited.add(start);\n\n    while (stack.length > 0) {\n      const currentNode = stack.pop();\n      const neighbors = this.graph[currentNode];\n      for (const neighbor in neighbors) {\n        if (!visited.has(neighbor)) {\n          stack.push(neighbor);\n          visited.add(neighbor);\n        }\n      }\n    }\n  }\n\n  bfs(start) {\n    const queue = [start];\n    const visited = new Set();\n    visited.add(start);\n\n    while (queue.length > 0) {\n      const currentNode = queue.shift();\n      const neighbors = this.graph[currentNode];\n      for (const neighbor in neighbors) {\n        if (!visited.has(neighbor)) {\n          queue.push(neighbor);\n          visited.add(neighbor);\n        }\n      }\n    }\n  }\n}\n\nfunction dijkstra_computation(length, width, start, end) {\n  const graph = new Graph(length, width);\n  return graph.dijkstra(start, end);\n}\n\nexport default dijkstra_computation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}